#ifndef _INCLUDE_LIGHTING
#define _INCLUDE_LIGHTING

struct PointLight {
  vec3 pos;
  vec3 color;
};

layout(binding = 1, std430) buffer SSBO {
  PointLight point_lights[];
}
ssbo;

float oren_nayer(vec3 v, vec3 l, vec3 n, float r) {
	float r2 = r*r;
    float a = 1.0 - 0.5*(r2/(r2+0.57));
    float b = 0.45*(r2/(r2+0.09));

    float nl = dot(n, l);
    float nv = dot(n, v);

    float ga = dot(v-n*nv,n-n*nl);

	return max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));
}

vec3 get_point_light_radiance(vec3 world_pos, vec3 normal) {
  vec3 result = vec3(0.0);

  vec3 view_dir = -normalize(world_pos);

  for (int i = 0; i < ubo.scene.point_light_count; ++i) {
    vec3 light_color = ssbo.point_lights[i].color;

    float roughness = 0.7;

    vec3 light_dir = ssbo.point_lights[i].pos - world_pos;
    float inv_distance = inversesqrt(dot(light_dir, light_dir));
    light_dir *= inv_distance;

    float attenuation = inv_distance * inv_distance;

    vec3 diffuse = oren_nayer(view_dir, light_dir, normal, roughness) * light_color * attenuation;
    result += diffuse;
  }

  return result;
}

#endif